const { Markup } = require('telegraf');
const { loadUsers, saveUser } = require('../../database/userModel');
const { loadUserReports, saveReport, getReportText } = require('../../database/reportModel');
const { OBJECTS_LIST_CYRILLIC, OBJECT_GROUPS, GENERAL_GROUP_CHAT_ID } = require('../../config/config');
const { clearPreviousMessages } = require('../utils');

async function showDownloadReport(ctx) {
    const userId = ctx.from.id.toString();
    const users = await loadUsers();

    if (!users[userId]?.isApproved) {
        return ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏ –æ—Ç—á–µ—Ç–æ–≤.');
    }

    await clearPreviousMessages(ctx, userId);

    const buttons = OBJECTS_LIST_CYRILLIC.map((obj, index) =>
        [Markup.button.callback(obj, `download_report_file_${index}`)]
    );
    buttons.push([Markup.button.callback('‚Ü©Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', 'main_menu')]);

    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–∫—Ç –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏ –æ—Ç—á–µ—Ç–∞:', Markup.inlineKeyboard(buttons));
}

async function downloadReportFile(ctx, objectIndex) {
    const userId = ctx.from.id.toString();
    const objectName = OBJECTS_LIST_CYRILLIC[objectIndex];
    if (!objectName) return ctx.reply('–û—à–∏–±–∫–∞: –æ–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.');

    const reportText = await getReportText(objectName);
    if (!reportText) {
        return ctx.reply(`–û—Ç—á–µ—Ç –¥–ª—è –æ–±—ä–µ–∫—Ç–∞ "${objectName}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
    }

    await clearPreviousMessages(ctx, userId);

    await ctx.replyWithDocument({
        source: Buffer.from(reportText, 'utf-8'),
        filename: `${objectName}_report_${new Date().toISOString().split('T')[0]}.txt`
    });
}

async function createReport(ctx) {
    const userId = ctx.from.id.toString();
    const users = await loadUsers();
    if (users[userId].position !== '–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å —Ä–∞–±–æ—Ç' || !users[userId].isApproved) {
        return ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç—á–µ—Ç–æ–≤.');
    }

    await clearPreviousMessages(ctx, userId);

    const buttons = users[userId].selectedObjects.map((obj, index) =>
        [Markup.button.callback(obj, `select_object_${index}`)]
    );
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–∫—Ç –∏–∑ —Å–ø–∏—Å–∫–∞:', Markup.inlineKeyboard(buttons));
}

async function handleReportText(ctx, userId, state) {
    const users = await loadUsers();
    const date = new Date().toISOString().split('T')[0];
    const timestamp = new Date().toISOString();
    const reportId = `${date}_${users[userId].nextReportId++}`;
    const report = {
        reportId,
        userId,
        objectName: state.report.objectName,
        date,
        timestamp,
        workDone: state.report.workDone,
        materials: state.report.materials,
        groupMessageId: null,
        generalMessageId: null
    };

    const reportText = `
üìÖ –û–¢–ß–ï–¢ –ó–ê ${date}  
üè¢ ${state.report.objectName}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ 
üë∑ ${users[userId].fullName} 

–í–´–ü–û–õ–ù–ï–ù–ù–´–ï –†–ê–ë–û–¢–´:  
${state.report.workDone}  

–ü–û–°–¢–ê–í–õ–ï–ù–ù–´–ï –ú–ê–¢–ï–†–ò–ê–õ–´:  
${state.report.materials}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
    `.trim();

    const groupChatId = OBJECT_GROUPS[state.report.objectName] || GENERAL_GROUP_CHAT_ID;
    const groupMessage = await ctx.telegram.sendMessage(groupChatId, reportText);
    const generalMessage = await ctx.telegram.sendMessage(GENERAL_GROUP_CHAT_ID, reportText);

    report.groupMessageId = groupMessage.message_id;
    report.generalMessageId = generalMessage.message_id;

    await saveReport(userId, report);
    await saveUser(userId, users[userId]);

    await clearPreviousMessages(ctx, userId);

    await ctx.reply(`‚úÖ –í–∞—à –æ—Ç—á–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω:\n\n${reportText}`);
}

async function showReportObjects(ctx) {
    const userId = ctx.from.id.toString();
    const users = await loadUsers();
    const reports = await loadUserReports(userId);

    await clearPreviousMessages(ctx, userId);

    if (Object.keys(reports).length === 0) {
        return ctx.reply('–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –æ—Ç—á–µ—Ç–æ–≤.');
    }

    const uniqueObjects = [...new Set(Object.values(reports).map(r => r.objectName))];
    const buttons = uniqueObjects.map((obj, index) =>
        [Markup.button.callback(obj, `select_report_object_${index}`)]
    );
    buttons.push([Markup.button.callback('‚Ü©Ô∏è –ù–∞–∑–∞–¥', 'profile')]);

    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–∫—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ—Ç—á–µ—Ç–æ–≤:', Markup.inlineKeyboard(buttons));
}

async function showReportDates(ctx, objectIndex) {
    const userId = ctx.from.id.toString();
    const reports = await loadUserReports(userId);
    const uniqueObjects = [...new Set(Object.values(reports).map(r => r.objectName))];
    const objectName = uniqueObjects[objectIndex];

    await clearPreviousMessages(ctx, userId);

    const objectReports = Object.values(reports).filter(r => r.objectName === objectName);
    const uniqueDates = [...new Set(objectReports.map(r => r.date))];
    const buttons = uniqueDates.map((date, index) =>
        [Markup.button.callback(date, `select_report_date_${objectIndex}_${index}`)]
    );
    buttons.push([Markup.button.callback('‚Ü©Ô∏è –ù–∞–∑–∞–¥', 'view_reports')]);

    await ctx.reply(`–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–ª—è –æ–±—ä–µ–∫—Ç–∞ "${objectName}":`, Markup.inlineKeyboard(buttons));
}

async function showReportTimestamps(ctx, objectIndex, dateIndex) {
    const userId = ctx.from.id.toString();
    const reports = await loadUserReports(userId);
    const uniqueObjects = [...new Set(Object.values(reports).map(r => r.objectName))];
    const objectName = uniqueObjects[objectIndex];
    const objectReports = Object.values(reports).filter(r => r.objectName === objectName);
    const uniqueDates = [...new Set(objectReports.map(r => r.date))];
    const selectedDate = uniqueDates[dateIndex];

    await clearPreviousMessages(ctx, userId);

    const dateReports = objectReports.filter(r => r.date === selectedDate);
    const buttons = dateReports.map((report, index) => {
        const time = new Date(report.timestamp).toLocaleTimeString('ru-RU', { timeZone: 'Europe/Moscow' });
        return [Markup.button.callback(time, `select_report_time_${objectIndex}_${dateIndex}_${index}`)];
    });
    buttons.push([Markup.button.callback('‚Ü©Ô∏è –ù–∞–∑–∞–¥', `select_report_object_${objectIndex}`)]);

    await ctx.reply(`–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –æ—Ç—á–µ—Ç–∞ –¥–ª—è "${objectName}" –∑–∞ ${selectedDate}:`, Markup.inlineKeyboard(buttons));
}

async function showReportDetails(ctx, objectIndex, dateIndex, timeIndex) {
    const userId = ctx.from.id.toString();
    const reports = await loadUserReports(userId);
    const uniqueObjects = [...new Set(Object.values(reports).map(r => r.objectName))];
    const objectName = uniqueObjects[objectIndex];
    const objectReports = Object.values(reports).filter(r => r.objectName === objectName);
    const uniqueDates = [...new Set(objectReports.map(r => r.date))];
    const selectedDate = uniqueDates[dateIndex];
    const dateReports = objectReports.filter(r => r.date === selectedDate);
    const report = dateReports[timeIndex];

    await clearPreviousMessages(ctx, userId);

    const reportText = `
üìÖ –û–¢–ß–ï–¢ –ó–ê ${report.date}  
üè¢ ${report.objectName}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ 
–í—Ä–µ–º—è: ${new Date(report.timestamp).toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}  
üë∑ ${ctx.from.first_name}  

–í–´–ü–û–õ–ù–ï–ù–ù–´–ï –†–ê–ë–û–¢–´:  
${report.workDone}  

–ü–û–°–¢–ê–í–õ–ï–ù–ù–´–ï –ú–ê–¢–ï–†–ò–ê–õ–´:  
${report.materials}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
    `.trim();

    const buttons = [
        [Markup.button.callback('‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å', `edit_report_${objectIndex}_${dateIndex}_${timeIndex}`)],
        [Markup.button.callback('‚Ü©Ô∏è –ù–∞–∑–∞–¥', `select_report_date_${objectIndex}_${dateIndex}`)]
    ];

    await ctx.reply(reportText, Markup.inlineKeyboard(buttons));
}

async function editReport(ctx, objectIndex, dateIndex, timeIndex) {
    const userId = ctx.from.id.toString();
    const reports = await loadUserReports(userId);
    const uniqueObjects = [...new Set(Object.values(reports).map(r => r.objectName))];
    const objectName = uniqueObjects[objectIndex];
    const objectReports = Object.values(reports).filter(r => r.objectName === objectName);
    const uniqueDates = [...new Set(objectReports.map(r => r.date))];
    const selectedDate = uniqueDates[dateIndex];
    const dateReports = objectReports.filter(r => r.date === selectedDate);
    const report = dateReports[timeIndex];

    if (!report || !report.reportId) {
        await clearPreviousMessages(ctx, userId);
        return ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –æ—Ç—á—ë—Ç –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.');
    }

    await clearPreviousMessages(ctx, userId);

    ctx.state.userStates[userId] = {
        step: 'editWorkDone',
        report: { ...report, originalReportId: report.reportId },
        messageIds: ctx.state.userStates[userId].messageIds
    };
    await ctx.reply('üí° –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç–∞—Ö:');
}

async function handleEditedReport(ctx, userId, state) {
    const users = await loadUsers();
    const originalReportId = state.report.originalReportId;
    let originalReport = null;

    if (originalReportId) {
        const userReports = await loadUserReports(userId);
        originalReport = userReports[originalReportId];
    }

    const newTimestamp = new Date().toISOString();
    const newReportId = `${state.report.date}_${users[userId].nextReportId++}`;
    const newReport = {
        reportId: newReportId,
        userId,
        objectName: state.report.objectName,
        date: state.report.date,
        timestamp: newTimestamp,
        workDone: state.report.workDone,
        materials: state.report.materials,
        groupMessageId: null,
        generalMessageId: null
    };

    const reportText = `
üìÖ –û–¢–ß–ï–¢ –ó–ê ${newReport.date} (–û–ë–ù–û–í–õ–Å–ù)  
üè¢ ${newReport.objectName}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ 
üë∑ ${users[userId].fullName} 

–í–´–ü–û–õ–ù–ï–ù–ù–´–ï –†–ê–ë–û–¢–´:  
${newReport.workDone}  

–ü–û–°–¢–ê–í–õ–ï–ù–ù–´–ï –ú–ê–¢–ï–†–ò–ê–õ–´:  
${newReport.materials}  
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
    `.trim();

    const groupChatId = OBJECT_GROUPS[newReport.objectName] || GENERAL_GROUP_CHAT_ID;

    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    if (originalReport) {
        if (originalReport.groupMessageId) {
            await ctx.telegram.deleteMessage(groupChatId, originalReport.groupMessageId)
                .catch(e => console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ${originalReport.groupMessageId}: ${e.message}`));
        }
        if (originalReport.generalMessageId) {
            await ctx.telegram.deleteMessage(GENERAL_GROUP_CHAT_ID, originalReport.generalMessageId)
                .catch(e => console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ${originalReport.generalMessageId}: ${e.message}`));
        }

        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –æ—Ç—á—ë—Ç –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        const client = await require('../../database/db').pool.connect();
        try {
            await client.query('DELETE FROM reports WHERE reportId = $1', [originalReportId]);
        } finally {
            client.release();
        }
    } else {
        console.log(`–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: —Å—Ç–∞—Ä—ã–π –æ—Ç—á—ë—Ç —Å ID ${originalReportId} –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è userId ${userId}`);
    }

    // –ü—É–±–ª–∏–∫—É–µ–º –Ω–æ–≤—ã–π –æ—Ç—á—ë—Ç
    const groupMessage = await ctx.telegram.sendMessage(groupChatId, reportText);
    const generalMessage = await ctx.telegram.sendMessage(GENERAL_GROUP_CHAT_ID, reportText);

    newReport.groupMessageId = groupMessage.message_id;
    newReport.generalMessageId = generalMessage.message_id;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π –æ—Ç—á—ë—Ç
    await saveReport(userId, newReport);
    await saveUser(userId, users[userId]);

    await clearPreviousMessages(ctx, userId);

    await ctx.reply(`‚úÖ –í–∞—à –æ—Ç—á—ë—Ç –æ–±–Ω–æ–≤–ª—ë–Ω:\n\n${reportText}`, Markup.inlineKeyboard([
        [Markup.button.callback('‚Ü©Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç', 'profile')]
    ]));
}

module.exports = (bot) => {
    bot.action('download_report', showDownloadReport);
    bot.action(/download_report_file_(\d+)/, (ctx) => downloadReportFile(ctx, parseInt(ctx.match[1], 10)));
    bot.action('create_report', createReport);
    bot.action(/select_object_(\d+)/, async (ctx) => {
        const userId = ctx.from.id.toString();
        const objectIndex = parseInt(ctx.match[1], 10);
        const users = await loadUsers();
        const selectedObject = users[userId].selectedObjects[objectIndex];
        if (!selectedObject) return;

        await clearPreviousMessages(ctx, userId);

        ctx.state.userStates[userId] = { step: 'workDone', report: { objectName: selectedObject }, messageIds: ctx.state.userStates[userId].messageIds };
        await ctx.reply('üí° –í–≤–µ–¥–∏—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç:');
    });

    bot.action('view_reports', showReportObjects);
    bot.action(/select_report_object_(\d+)/, (ctx) => showReportDates(ctx, parseInt(ctx.match[1], 10)));
    bot.action(/select_report_date_(\d+)_(\d+)/, (ctx) => showReportTimestamps(ctx, parseInt(ctx.match[1], 10), parseInt(ctx.match[2], 10)));
    bot.action(/select_report_time_(\d+)_(\d+)_(\d+)/, (ctx) => showReportDetails(ctx, parseInt(ctx.match[1], 10), parseInt(ctx.match[2], 10), parseInt(ctx.match[3], 10)));
    bot.action(/edit_report_(\d+)_(\d+)_(\d+)/, (ctx) => editReport(ctx, parseInt(ctx.match[1], 10), parseInt(ctx.match[2], 10), parseInt(ctx.match[3], 10)));

    bot.on('text', async (ctx) => {
        const userId = ctx.from.id.toString();
        const state = ctx.state.userStates[userId];
        console.log(`–ü–æ–ª—É—á–µ–Ω —Ç–µ–∫—Å—Ç –æ—Ç userId ${userId}: "${ctx.message.text}". –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:`, state);

        if (!state || (!state.step?.includes('workDone') && !state.step?.includes('materials') && !state.step?.includes('editFullName') && !state.step?.includes('editWorkDone') && !state.step?.includes('editMaterials'))) {
            await clearPreviousMessages(ctx, userId);
            await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–Ω–æ–≤–æ, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—ã –∏–ª–∏ –∫–Ω–æ–ø–∫–∏.');
            return;
        }

        await clearPreviousMessages(ctx, userId);

        if (state.step === 'workDone') {
            state.report.workDone = ctx.message.text.trim();
            state.step = 'materials';
            await ctx.reply('üí° –í–≤–µ–¥–∏—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö:');
        } else if (state.step === 'materials') {
            state.report.materials = ctx.message.text.trim();
            await handleReportText(ctx, userId, state);
            state.step = null;
            state.report = {};
        } else if (state.step === 'editFullName') {
            const users = await loadUsers();
            users[userId].fullName = ctx.message.text.trim();
            await saveUser(userId, users[userId]);
            await ctx.reply(`–§–ò–û –æ–±–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ "${users[userId].fullName}".`);
            state.step = null;
            await require('./menu').showProfile(ctx);
        } else if (state.step === 'editWorkDone') {
            state.report.workDone = ctx.message.text.trim();
            state.step = 'editMaterials';
            await ctx.reply('üí° –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö:');
        } else if (state.step === 'editMaterials') {
            state.report.materials = ctx.message.text.trim();
            await handleEditedReport(ctx, userId, state);
            state.step = null;
            state.report = {};
        }
    });

    bot.action('edit_fullName', async (ctx) => {
        const userId = ctx.from.id.toString();
        await clearPreviousMessages(ctx, userId);
        const existingMessageIds = ctx.state.userStates[userId]?.messageIds || [];
        ctx.state.userStates[userId] = { step: 'editFullName', messageIds: existingMessageIds };
        console.log(`–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ editFullName –¥–ª—è userId ${userId}. State:`, ctx.state.userStates[userId]);
        await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –Ω–æ–≤–æ–µ –§–ò–û:');
    });
};